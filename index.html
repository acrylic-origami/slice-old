<html>
	<head>
		<style type="text/css">
			body, html {
				width:100%;
				height:100%;
				margin:0;
			}
			canvas {
				display:block;
			}
			.marker {
				position:absolute;
				z-index:1;
				left:49%;
				top:49%;
				background-color:#00F;
				width:2%;
				height:2%;
			}
		</style>
		<script type="text/javascript" src="js/vendor/decomp.min.js"></script>
		<script type="text/javascript" src="js/vendor/matter.js"></script>
		<script type="text/javascript">
			var Vector = Matter.Vector;
			function intersect(target, knife) {
				// thanks https://stackoverflow.com/a/565282/3925507 !
				var knife_delta = Vector.sub(knife[1], knife[0]);
				var target_delta = Vector.sub(target[1], target[0]);
				var u = Vector.cross(
					Vector.sub(target[0], knife[0]),
					knife_delta
				) / Vector.cross(
					knife_delta,
					target_delta
				);
				var t = Vector.cross(
					Vector.sub(target[0], knife[0]),
					target_delta
				) / Vector.cross(
					knife_delta,
					target_delta
				);
				if(0 <= t && t <= 1 && 0 <= u && u <= 1) {
					return u; // only interested in target parameter
				}
				else
					return null;
			}
			function make_body_meta(vertices) {
				var position = Matter.Vertices.centre(vertices);
				var bary_bounds = Matter.Bounds.create(vertices);
				Matter.Bounds.translate(bary_bounds, Vector.mult(position, -1));
				return {
					vertices: vertices.map(function(V) {
						return Vector.sub(V, position);
					}),
					bary_bounds: bary_bounds,
					original_position: position,
					prev: {
						position: position,
						angle: 0.0
					}
				};
			}
			function might_slice(bound, knife) {
				var bound_flags = [
					[
						knife[0].x > bound.min.x && knife[0].x < bound.max.x,
						knife[0].y > bound.min.y && knife[0].y < bound.max.y,
					],
					[
						knife[1].x > bound.min.x && knife[1].x < bound.max.x,
						knife[1].y > bound.min.y && knife[1].y < bound.max.y
					]
				];
				if(
					bound_flags[0][0] && bound_flags[0][1] &&
					bound_flags[1][0] && bound_flags[1][1]
				)
					return true;
				else if(
					bound_flags[0].toString() !== bound_flags[1].toString() && (
						bound_flags[0][0] || bound_flags[0][1] &&
						bound_flags[1][0] || bound_flags[1][1]
					)
				)
					return true;
				
				return false;
			}
			function barycentrify(frame, point) {
				return Vector.rotate(Vector.sub(point, frame.position), -frame.angle);
			}
			function update(frame, meta) {
				return meta.vertices.map(function(V) {
					return Vector.rotate(
						Vector.add(V, Vector.sub(meta.original_position, frame.position)),
						frame.angle
					)
				})
			}
			// window.addEventListener('resize', on_resize_reload);
			window.addEventListener('load', function() {
				// on_resize_reload();
				
				var engine = Matter.Engine.create();
				// engine.world.gravity.y = 0;
				var render = Matter.Render.create({
					element: document.body,
					engine: engine,
					options: {
						wireframes: false,
						width: window.innerWidth,
						height: window.innerHeight
					}
				});
				var mouse = Matter.Mouse.create(document.body);
				(function() {
					var active_line = null; // { entry_cut: ?number, interior: Vector[] };
					var active_body = null; // number
					var knife = [ mouse.absolute ];
					
					var original = Matter.Bodies.rectangle(window.innerWidth / 2, window.innerHeight / 2, window.innerWidth / 2, window.innerHeight / 2, {
						render: { fillStyle: '#FF0000' },
						isStatic: true
					});
					
					Matter.World.addBody(engine.world, original);
					var body_meta = [ make_body_meta(original.vertices) ]; // expect convex beginning shape
					
					(function anim_loop() {
						window.requestAnimationFrame(anim_loop);
						Matter.Engine.update(engine, 1000 / 60);
						
						if(knife.length > 1) {
							knife = [ knife[1], Vector.clone(mouse.absolute) ];
							// knife = [ Vector.create(window.innerWidth / 2, window.innerHeight * 0.7), Vector.create(window.innerWidth / 2, window.innerHeight * 0.7) ];
							
							var slices = []; // Array<{ outgoing: number, incoming: Body[] }>
							var bodies = Matter.Composite.allBodies(engine.world);
							
							// console.log(active_body);
							var next_active_line = active_line;
							var next_active_body = active_body;
							for(var i = 0; i < bodies.length; i++) {
								var bary_knife = [
									barycentrify(body_meta[i].prev, knife[0]),
									barycentrify(bodies[i], knife[1])
								];
								body_meta[i].prev = {
									position: Vector.clone(bodies[i].position),
									angle: bodies[i].angle
								};
								
								if(might_slice(body_meta[i].bary_bounds, bary_knife)) {
									var cuts = [];
									var new_vertices = [];
									for(var j = 0; j < body_meta[i].vertices.length; j++) {
										var t = intersect(
											[
												body_meta[i].vertices[j],
												body_meta[i].vertices[(j + 1) % body_meta[i].vertices.length]
											],
											bary_knife
										);
										// if(j === 0) {
										// 	console.log(JSON.stringify([
										// 		body_meta[i].vertices[j],
										// 		body_meta[i].vertices[(j + 1) % body_meta[i].vertices.length]
										// 	]), JSON.stringify(bary_knife));
										// }
										if(t != null) {
											// console.log('CUT!');
											cuts.push(j + t);
											if(active_body === bodies[i] && cuts.length === 1 && active_line.interior.length > 0) {
												var cut_points = [
													Vector.add(
														Vector.mult(
															body_meta[i].vertices[Math.floor(active_line.entry_cut)],
															1 - active_line.entry_cut + Math.floor(active_line.entry_cut)
														),
														Vector.mult(
															body_meta[i].vertices[Math.ceil(active_line.entry_cut) % body_meta[i].vertices.length],
															active_line.entry_cut - Math.floor(active_line.entry_cut)
														)
													),
													Vector.add(
														Vector.mult(
															body_meta[i].vertices[j],
															1 - t
														),
														Vector.mult(
															body_meta[i].vertices[(j + 1) % body_meta[i].vertices.length],
															t
														)
													)
												];
												var cut_line = [cut_points[0]].concat(active_line.interior).concat([cut_points[1]]);
												
												new_vertices.splice(
													new_vertices.length,
													0,
													// continuous curve (without wraparound 0; subcurve from body is necessarily clockwise)
													body_meta[i].vertices.slice(
														Math.ceil(Math.min(active_line.entry_cut, j + t)),
														Math.ceil(Math.max(active_line.entry_cut, j + t)) // TODO: must compensate potentially for missing 1st point from rounding up somewhere between length - 1 and length
													).concat(
														active_line.entry_cut > j + t ?
															cut_line :
															cut_line.slice(0).reverse()
													).map(function(V) {
														return Vector.add(Vector.rotate(V, bodies[i].angle), bodies[i].position);
													}),
													// discontinuous curve (wraparound 0)
													body_meta[i].vertices.slice(
														Math.ceil(Math.max(active_line.entry_cut, j + t))
													).concat(
														body_meta[i].vertices.slice(0, Math.ceil(Math.min(active_line.entry_cut, j + t)))
													).concat(
														active_line.entry_cut > j + t ?
															cut_line.slice(0).reverse() :
															cut_line
													).map(function(V) {
														return Vector.add(Vector.rotate(V, bodies[i].angle), bodies[i].position);
													})
												)
											}
											else if(active_body !== bodies[i] && cuts.length % 2 === 0 && cuts.length > 0) {
												// a lot of repetition tbh
												var entry_cut = cuts[cuts.length - 2];
												var cut_points = [
													Vector.add(
														Vector.mult(
															body_meta[i].vertices[Math.floor(entry_cut)],
															1 - entry_cut + Math.floor(entry_cut)
														),
														Vector.mult(
															body_meta[i].vertices[Math.ceil(entry_cut)],
															entry_cut - Math.floor(entry_cut)
														)
													),
													Vector.add(
														Vector.mult(
															body_meta[i].vertices[j],
															1 - t
														),
														Vector.mult(
															body_meta[i].vertices[(j + 1) % body_meta[i].vertices.length],
															t
														)
													)
												];
												new_vertices.splice(
													new_vertices.length,
													0,
													// continuous curve (without wraparound 0; subcurve from body is necessarily clockwise)
													body_meta[i].vertices.slice(
														Math.ceil(Math.min(entry_cut, j + t)),
														Math.ceil(Math.max(entry_cut, j + t)) // TODO: must compensate potentially for missing 1st point from rounding up somewhere between length - 1 and length
													).concat(
														entry_cut > j + t ?
															cut_points :
															cut_points.reverse()
													).map(function(V) {
														return Vector.add(Vector.rotate(V, bodies[i].angle), bodies[i].position);
													}),
													body_meta[i].vertices.slice(
														Math.ceil(Math.max(entry_cut, j + t))
													).concat(
														body_meta[i].vertices.slice(0, Math.ceil(Math.min(entry_cut, j + t)))
													).concat(
														entry_cut > j + t ?
															cut_points.reverse() :
															cut_points
													).map(function(V) {
														return Vector.add(Vector.rotate(V, bodies[i].angle), bodies[i].position);
													})
												);
											}
										}
									}
									
									// console.log(i, active_body, cuts);
									
									if(new_vertices.length > 0) {
										slices.push({
											outgoing: i,
											incoming: new_vertices
										});
									}
									if(active_body === bodies[i]) {
										if(cuts.length % 2 === 1) {
											// odd # cuts, exit this body
											next_active_body = null;
											next_active_line = null;
										}
										else if(cuts.length % 2 === 0 && cuts.length > 0) {
											next_active_line = {
												entry_cut: cuts[cuts.length - 1],
												interior: [ bary_knife[1] ] // TODO: this won't work because the barycenter could change after all the slicing
											};
										}
										else {
											next_active_line.interior.push(bary_knife[1]);
										}
									}
									else if(active_body !== bodies[i] && cuts.length % 2 === 1) {
										// mutually exclusive with staying in that other body
										next_active_body = bodies[i];
										next_active_line = {
											entry_cut: cuts[cuts.length - 1],
											interior: [ bary_knife[1] ]
										};
									}
								}
							}
							active_line = next_active_line;
							active_body = next_active_body;
							
							for(var i = 0; i < slices.length; i++) {
								// assume outgoing from slices are ascending order
								var should_be_static = bodies[slices[i].outgoing].isStatic ? Math.floor(Math.random() * slices[i].incoming.length) : -1;
								
								body_meta.splice(slices[i].outgoing - i, 1);
								Matter.Composite.removeBody(engine.world, bodies[slices[i].outgoing]);
								for(var j = 0; j < slices[i].incoming.length; j++) {
									body_meta.push(make_body_meta(slices[i].incoming[j]))
									var center = Matter.Vertices.centre(slices[i].incoming[j]);
									var body = Matter.Bodies.fromVertices(center.x, center.y, slices[i].incoming[j]);
									if(body != null) {
										Matter.Body.setStatic(body, j === should_be_static);
										Matter.Body.setVelocity(body, bodies[slices[i].outgoing].velocity);
										Matter.Body.setAngularVelocity(body, bodies[slices[i].outgoing].angularVelocity);
										Matter.World.addBody(engine.world, body);
									}
								}
								// debugger;
							}
						}
						else
							knife.push(mouse.absolute);
					})();
				})();
				
				Matter.Render.run(render);
			});
		</script>
	</head>
	
	<body>
		<!-- <div class="marker" style="left:49%; top:49%; background-color:#00F;"></div>
		<div class="marker" style="left:49%; top:69%; background-color:#0F0;"></div> -->
	</body>
</html>